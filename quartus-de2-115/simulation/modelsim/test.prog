00000000000000 //0.     nop
11000010101011 //1.     movlw 0xAB          W <= 0xAB
00000010100000 //2.     movwf 0x20          mem[0x20] <= W = 0xAB
11000011001101 //3.     movlw 0xCD          W <= 0xCD
00000010100001 //4.     movwf 0x21          mem[0x21] <= W = 0xCD
00011100100000 //5.     addwf 0 0x20        W <= W + mem[0x20] = 0xAB + 0xCD = Carry and 0x78
00100000100000 //6.     movfw 0 0x20        W <= mem[0x20] = 0xAB
00010100100001 //7.     andwf 0 0x21        W <= W & mem[0x21] = 0xAB & 0xCD = 0x89
00000110100001 //8.     clrf 0x21           mem[0x21] <= 0x00 and Z = 1
00000110100010 //9.     clrf 0x22           mem[0x22] <= 0x00 and Z = 1
00010100100000 //10.    andwf 0 0x20        W <= W & mem[0x20] = 0x89 & 0xAB = 0x89 and !Z
00010110100000 //11.    andwf 1 0x20        mem[0x20] <= W & mem[0x20] = 0x89 & 0xAB = 0x89 and !Z
00010100100010 //12.    andwf 0 0x22        W <= W & mem[0x22] = 0x89 & 0x00 = 0x00 and Z
00000110000011 //13.    clrf STATUS         STATUS <= 0x00 and Z = 0x04
00100000000011 //14.    movfw 0 STATUS      W <= STATUS = 0x04 and !Z
00000100000000 //15.    clrw                W <= 0x00 and Z
00100110100000 //16.    comf 1 0x20         mem[0x20] <= ~mem[0x20] = 0x76
00100100100001 //17.    comf 0 0x21         W <= ~mem[0x21] = 0xFF
00100110100001 //18.    comf 1 0x21         mem[0x21] <= ~mem[0x21] = 0xFF
00101010100000 //19.    incf 1 0x20         mem[0x20] <= mem[0x20] + 1 = 0x76 + 1 = 0x77
00101000100001 //20.    incf 0 0x21         W <= mem[0x21] + 1 = 0xFF + 1 = 0x00 and Z
11000000000001 //21.    movlw 0x01          W <= 0x01
00000010100010 //22.    movwf 0x22          mem[0x22] <= W = 0x01
00001110100000 //23.    decf 1 0x20         mem[0x20] <= mem[0x20] - 1 = 0x77 - 1 = 0x76
00001100100010 //24.    decf 0 0x22         W <= mem[0x22] - 1 = 0x01 - 1 = 0x00 and Z
00010000100000 //25.    iorwf 0 0x20        W <= W | mem[0x20] = 0x00 | 0x76 = 0x76
00010000100010 //26.    iorwf 0 0x22        W <= W | mem[0x22] = 0x76 | 0x01 = 0x77
00010010100000 //27.    iorwf 1 0x20        mem[0x20] <= W | mem[0x20] = 0x77 | 0x76 = 0x77
//test decfsz
00101110100000 //28.    decfsz 1 0x20       mem[0x20] <= mem[0x20] - 1 SZ = 0x77 - 1 SZ = 0x76, !Z, NO SKIP
11000010101011 //29.    movlw 0xAB          W <= 0xAB
00101100100010 //30.    decfsz 0 0x22       W <= mem[0x22] - 1 SZ = 0x01 - 1 SZ = 0x00 Z, SKIP
11000010101011 //31.    movlw 0xAB          SKIPPED W <= 0xAB
00101110100010 //32.    decfsz 1 0x22       mem[0x22] <= mem[0x22] - 1 SZ = 0x01 - 1 SZ = 0x00 Z, SKIP
11000010101011 //33.    movlw 0xAB          SKIPPED W <= 0xAB
00101110100000 //34.    decfsz 1 0x20       mem[0x20] <= mem[0x20] - 1 SZ = 0x76 - 1 SZ = 0x75, !Z, NO SKIP
11000011001101 //35.    movlw 0xCD          W <= 0xCD
//test incfsz
00111100100000 //36.    incfsz 0 0x20       W <= mem[0x20] + 1 SZ = 0x75 + 1 SZ = 0x76, !Z, NO SKIP
11000011111111 //37.    movlw 0xFF          W <= 0xFF
00000010110000 //38.    movwf 0x30          mem[0x30] <= W = 0xFF
00111100110000 //39.    incfsz 0 0x30       W <= mem[0x30] + 1 SZ = 0xFF + 1 SZ = 0x00, Z, SKIP
11000010101011 //40.    movlw 0xAB          SKIPPED W <= 0xAB
00111110110000 //41.    incfsz 1 0x30       mem[0x30] <= mem[0x30] + 1 SZ = 0xFF + 1 SZ = 0x00, Z, SKIP
11000010101011 //42.    movlw 0xAB          SKIPPED W <= 0xAB
00111110110000 //43.    incfsz 1 0x30       mem[0x30] <= mem[0x30] + 1 SZ = 0x00 + 1 SZ = 0x01, Z, NO SKIP
11000010101011 //44.    movlw 0xAB          W <= 0xAB
//test rlf
00000010100010 //45.    movwf 0x22          mem[0x22] <= W = 0xAB
00110110100010 //46.    rlf 1 0x22          mem[0x22] <= mem[0x22] << 1 = 0x56 and C (Z not affected)
00110100100010 //47.    rlf 0 0x22          W <= mem[0x22] << 1 = 0xAC and !C (Z not affected)
//test rrf
11000010101011 //48.    movlw 0xAB          W <= 0xAB
00000010100010 //49.    movwf 0x22          mem[0x22] <= W = 0xAB
00110010100010 //50.    rrf 1 0x22          mem[0x22] <= mem[0x22] << 1 = 0x55 and C (Z not affected)
00110010100010 //51.    rrf 1 0x22          mem[0x22] <= mem[0x22] << 1 = 0x2A and C (Z not affected)
00110000100010 //52.    rrf 0 0x22          W <= mem[0x22] << 1 = 0x15 and !C (Z not affected)
//test subwf
00001010100010 //53.    subwf 1 0x22        mem[0x22] <= mem[0x22] - W = 0x2A - 0x15 = 0x15 !Z !C 
00001000100010 //54.    subwf 0 0x22        W         <= mem[0x22] - W = 0x15 - 0x15 = 0x0 Z !C 
11000010101011 //55.    movlw 0xAB          W         <= 0xAB
00001010100010 //56.    subwf 1 0x22        mem[0x22] <= mem[0x22] - W = 0x15 - 0xAB = 0x6a !Z C 


10100000000001 //xx.    goto 1              PC <= 0x01 (the first movlw instruction)
11000011101111 //xx.    movlw 0xEF    
